/*
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1
 * 
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 ("License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.zimbra.com/license
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 * 
 * The Original Code is: Zimbra Collaboration Suite Server.
 * 
 * The Initial Developer of the Original Code is Zimbra, Inc.
 * Portions created by Zimbra are Copyright (C) 2005, 2006 Zimbra, Inc.
 * All Rights Reserved.
 * 
 * Contributor(s): 
 * 
 * ***** END LICENSE BLOCK *****
 */

package com.zimbra.cs.mailbox.calendar;

import java.util.*;

import java.text.ParseException;

import com.zimbra.common.service.ServiceException;
import com.zimbra.common.util.ZimbraLog;
import com.zimbra.common.util.ListUtil;
import com.zimbra.cs.mailbox.CalendarItem;
import com.zimbra.cs.mailbox.Metadata;
import com.zimbra.cs.mailbox.CalendarItem.Instance;
import com.zimbra.cs.service.mail.MailService;
import com.zimbra.soap.Element;



/**
 * @author tim
 * 
 * We use this class to represent a full iCal recurrence -- as such, it is really used in two distinct
 * ways:
 * 
 *   As a member of an Invite, this class (well, a tree of this) represents a combination of 
 * RRULE, EXRULE, RDATE, EXDATE which all generate instances of the same Invite.  All 
 * generated instances point to that same Invite.
 * 
 *   As a member of an CalendarItem, this tree represents the overall recurrence-rule for the calendar item.
 * IE there is a "default" Invite which generates a bunch of instances, and then there are Exceptions
 * which each have a RecurrenceId (which corresponds to an instance generated by the default) and which
 * override or cancel that instance.  The instances returned from an CalendarItem's Recurrence tree
 * can point to many Invites.  
 *
 */
public class Recurrence 
{
    /**
     * RecurrenceRule -- from the default invite.  
     * 
     * Can have add/subtract sub-parts as well as Exception parts  
     */
    public static final int TYPE_RECURRENCE = 1;
    
    /**
     * ExceptionRule -- an Exception (RecurrenceID != 0) invite
     * 
     * Has a RecurId and can also have add/subtract sub-parts
     */
    public static final int TYPE_EXCEPTION = 2;
    
    /**
     * Cancellation -- An exception with RFC2446 method=CANCEL
     * 
     * Has a RecurId.  
     */
    public static final int TYPE_CANCELLATION = 3; 

    /**
     * Always stored as part of SingleDates
     */
    public static final int TYPE_SINGLE_INSTANCE_DEPRECATED = 4;

    /**
     * Always stored as part of a Recurrence, Exception, or Cancellation -- a rule for generating dates
     * 
     * Use the getZRecur() API to access the rule itself 
     */
    public static final int TYPE_REPEATING = 5; 
    
    /**
     * Always stored as part of a Recurrence, Exception, or Cancellation --
     * a list of one or more SingleDates.DateValue objects
     */
    public static final int TYPE_SINGLE_DATES = 6;


    /**
     * @author tim
     *
     * Represents a full iCal recurrence ruleset -- including exceptions, etc.
     * 
     * The concrete subclasses are:
     *    SingleDates: a list of 1-time events
     *    
     *    SimpleRepeatingRule: anything that can be expressed in a single rule...RECUR in the iCal RFC
     *    
     *    RecurrenceRule: Rule which fully expresses iCal grammar (support Exceptions, EXRULE, etc)
     *    
     *    ExceptionRule: rule that has a RECURRENCE_ID which is used to determine when it applies
     * 
     */
    public interface IRecurrence extends Cloneable {
        public Metadata encodeMetadata();
        
        abstract List<Instance> expandInstances(CalendarItem calItem, long start, long end);
        
        // get the first time for which the rule has instances
        public ParsedDateTime getStartTime();
        // get the last time (-1 means forever) for which the rule has instances 
        public ParsedDateTime getEndTime();

        public Object clone();
        
        /**
         * @return TYPE_RECURRENCE, TYPE_EXCEPTION, TYPE_CANCELLATION, TYPE_SINGLE_DATES, or TYPE_REPEATING
         */
        public int getType();
        
        /**
         * @return an Iterator over all child rules that add instances to this current node, or NULL if none
         */
        public Iterator /* IRecurrence */ addRulesIterator();

        /**
         * @return an Iterator over all child rules that add instances to this current node, or NULL if none
         */
        public Iterator /* IRecurrence */ subRulesIterator();
        
        
        /**
         * @return Identifier for the Invite which created this particular rule
         */
        public InviteInfo getInviteInfo();
        
        
        /**
         * WARNING WARNING: this is a special call only used when initializing an INVITE,
         * basically it walks the entire Recurrence chain and sets the InvId to the
         * passed-in value....while this is OK in the case of a single-Invite's recurrence,
         * if this is called on an CalendarItem's Recurrence, it will cause Bad Things To Happen!
         *  
         * @param invId
         */
        public void setInviteId(InviteInfo invId);
        
        abstract public Element toXml(Element parent);
    }
    
    
    /**
     * @author tim
     *
     * Superset of IRecurrence for exception rules: they have a RecurId
     * 
     * Real implementations are ExceptionRule and CancellationRule
     */
    public static interface IException extends IRecurrence
    {
        public boolean matches(long date);
        
        public RecurId getRecurId();
    }
    
    /**
     * @author tim
     * 
     * A subnode which generates instances -- ie right now either a SingleDates 
     * or SimpleRepeatingRule
     *
     */
    public static interface IInstanceGeneratingRule extends IRecurrence {
        public InviteInfo getInviteInfo();
    }


    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    
    
    public static IRecurrence decodeMetadata(Metadata meta, TimeZoneMap tzmap)
    throws ServiceException {
        try {
            int ruleType = (int) meta.getLong(FN_RULE_TYPE);
            
            switch (ruleType) {
            case RULE_SIMPLE_REPEATING_RULE:
                return new SimpleRepeatingRule(meta, tzmap);
            case RULE_EXCEPTION_RULE:
                return new ExceptionRule(meta, tzmap);
            case RULE_RECURRENCE_RULE:
                return new RecurrenceRule(meta, tzmap);
            case RULE_SINGLE_DATES:
                return new SingleDates(meta, tzmap);
            }
        } catch (ParseException e) {
            throw ServiceException.FAILURE("Parse excetion on metadata: " + meta, e);
        }
        throw new IllegalArgumentException("Unknown IRecur type: " + meta.get(FN_RULE_TYPE));
    } 

    static final String FN_RULE_TYPE = "t";
    static final int RULE_SIMPLE_REPEATING_RULE = 2;
    static final int RULE_EXCEPTION_RULE = 3;
    static final int RULE_RECURRENCE_RULE = 4;
    static final int RULE_SINGLE_INSTANCE_DEPRECATED = 5;
    static final int RULE_SINGLE_DATES = 6;
    
    /**
     * @author tim
     * 
     * Internal Node -- basically just wraps an ArrayList of subrules and does
     * some convienence stuff (e.g. getStartTime calculates the earliest starting time 
     * for all the rules we're sorting, etc)
     *
     */
    public static class MultiRuleSorter
    {
        static private final String FN_NUM_RULES = "nr";
        static private final String FN_RULE = "r";
        
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_NUM_RULES, mRules.size());
            for (int i = 0; i < mRules.size(); i++)
                meta.put(FN_RULE + i, ((IRecurrence) mRules.get(i)).encodeMetadata());
            return meta;
        }

        public Object clone() {
            List<IRecurrence> newRules = new ArrayList<IRecurrence>();
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence rule = (IRecurrence) iter.next();
                newRules.add((IRecurrence) rule.clone());
            }
            return new MultiRuleSorter(newRules);
        }
        
        public Iterator<IRecurrence> iterator() {
            return mRules.iterator();
        }
        
        public MultiRuleSorter(Metadata meta, TimeZoneMap tzmap) throws ServiceException {
            int numRules = (int) meta.getLong(FN_NUM_RULES);
            mRules = new ArrayList<IRecurrence>(numRules);
            for (int i = 0; i < numRules; i++) {
                try {
                    mRules.add(Recurrence.decodeMetadata(meta.getMap(FN_RULE + i), tzmap));
                } catch(Exception e) {}
            }
        }

        public MultiRuleSorter(List<IRecurrence> rules) {
            assert((rules == null) || (rules.size() == 0) || (rules.get(0) instanceof IInstanceGeneratingRule));
            mRules = rules;
        }
        
        public void setInviteId(InviteInfo invId) {
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                cur.setInviteId(invId);
            }
        }

        public Element toXml(Element parent) {
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                parent.addElement(cur.toXml(parent));
            }
            return parent;
        }

        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) {
            List lists[] = new ArrayList[mRules.size()];
            int num = 0;
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                lists[num] = cur.expandInstances(calItem, start, end);
                num++;
            }
            
            List<Instance> toRet = new LinkedList<Instance>();
            ListUtil.mergeSortedLists(toRet, lists, true);
            return toRet;
        }
        
        public String toString() {
            StringBuffer toRet = new StringBuffer();
            toRet.append("(");
            for (Iterator iter = mRules.iterator();iter.hasNext();) {
                IRecurrence rule  = (IRecurrence)iter.next();
                toRet.append(rule.toString());
            } 
            toRet.append(")");
            return toRet.toString();
        }
        
        public ParsedDateTime getStartTime() {
            ParsedDateTime earliestStart = null;
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                ParsedDateTime start = cur.getStartTime();
                if (earliestStart == null || (start != null && start.compareTo(earliestStart) < 0)) {
                    earliestStart = start;
                }
            }
            return earliestStart;
        }
        
        public ParsedDateTime getEndTime() {
            ParsedDateTime latestEnd = null;
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                ParsedDateTime end = cur.getEndTime();
                if (latestEnd == null || (end != null && end.compareTo(latestEnd)>0)) {
                    latestEnd = end;
                }
            }
            return latestEnd;
        }
        
        private List<IRecurrence> mRules;
        
    }

    public static class SingleDates implements IInstanceGeneratingRule {
        private static final String FN_RDATE_EXDATE = "rexd";
        private static final String FN_DEFAULT_DURATION = "defdur";
        private static final String FN_INVID = "inv";

        public int getType() { return TYPE_SINGLE_DATES; }

        public RdateExdate getRdateExdate() { return mRdateExdate; }

        public Iterator addRulesIterator() { return null; }
        public Iterator subRulesIterator() { return null; }

        public void setInviteId(InviteInfo invId) {
            mInvId = invId;
        }

        public InviteInfo getInviteInfo() {
            return mInvId;
        }

        public String toString() {
            StringBuilder toRet = new StringBuilder("[");
            if (mRdateExdate != null) {
                if (mRdateExdate.isRDATE())
                    toRet.append("rdate=[");
                else
                    toRet.append("exdate=[");
                toRet.append(mRdateExdate.toString()).append("]");
            } else {
                toRet.append("rdate/exdate=<none>");
            }
            toRet.append(", defaultDuration=").append(mDefaultDuration.toString());
            if (mInvId != null)
                toRet.append(", InvId=").append(mInvId.toString()).append("]");
            
            return toRet.toString();
        }
        
        public ParsedDateTime getStartTime() {
            ParsedDateTime start = null;
            for (DateValue val : mDates) {
                ParsedDateTime valStart = val.getStartTime();
                if (start == null || start.compareTo(valStart) > 0)
                    start = valStart;
            }
            return start;
        }

        public ParsedDateTime getEndTime() {
            ParsedDateTime end = null;
            for (DateValue val : mDates) {
                ParsedDateTime valEnd = val.getEndTime();
                if (end == null || end.compareTo(valEnd) < 0)
                    end = valEnd;
            }
            return end;
        }

        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) {
            List<Instance> list = new ArrayList<Instance>();
            for (DateValue val : mDates) {
                ParsedDateTime valStart = val.getStartTime();
                ParsedDateTime valEnd = val.getEndTime();
                list.add(new Instance(calItem, mInvId, false,
                                      valStart.getUtcTime(), valEnd.getUtcTime(),
                                      true));
            }
            Collections.sort(list);
            return list;
        }

        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_RULE_TYPE, RULE_SINGLE_DATES);
            meta.put(FN_RDATE_EXDATE, mRdateExdate.encodeMetadata());
            meta.put(FN_DEFAULT_DURATION, mDefaultDuration);
            meta.put(FN_INVID, mInvId.encodeMetadata());
            return meta;
        }
        
        SingleDates(Metadata meta, TimeZoneMap tzmap) 
        throws ServiceException, ParseException {
            Metadata rexdate = meta.getMap(FN_RDATE_EXDATE);
            mRdateExdate = RdateExdate.decodeMetadata(rexdate, tzmap);
            mDefaultDuration = ParsedDuration.parse(meta.get(FN_DEFAULT_DURATION));
            mInvId = InviteInfo.fromMetadata(meta.getMap(FN_INVID), tzmap);
            setDates();
        }

        public SingleDates(RdateExdate rexdate, ParsedDuration defaultDuration) {
            this(rexdate, defaultDuration, null);
        }

        SingleDates(RdateExdate rexdate, ParsedDuration defaultDuration, InviteInfo invId) {
            mRdateExdate = rexdate;
            mDefaultDuration = defaultDuration;
            mInvId = invId;
            setDates();
        }

        private void setDates() {
            List<DateValue> list =
                new ArrayList<DateValue>(mRdateExdate.numValues());
            for (Iterator<Object> iter = mRdateExdate.valueIterator(); iter.hasNext(); ) {
                Object val = iter.next();
                if (val instanceof ParsedDateTime) {
                    ParsedDateTime start = (ParsedDateTime) val;
                    ParsedDateTime end = start.add(mDefaultDuration);
                    DateValue dtval = new DateValue(start, end);
                    list.add(dtval);
                } else if (val instanceof Period) {
                    Period p = (Period) val;
                    DateValue dtval = new DateValue(p.getStart(), p.getEnd());
                    list.add(dtval);
                }
            }
            mDates = list;
        }

        public Element toXml(Element parent) {
            return mRdateExdate.toXml(parent);
        }

        public Object clone() {
            return new SingleDates(mRdateExdate, mDefaultDuration, mInvId);
        }

        private RdateExdate mRdateExdate;
        private ParsedDuration mDefaultDuration;
        private InviteInfo mInvId;
        private List<DateValue> mDates;

        private static class DateValue {

            private ParsedDateTime mStart;
            private ParsedDateTime mEnd;

            public DateValue(ParsedDateTime start, ParsedDateTime end) {
                assert(start != null && end != null);
                mStart = start;
                mEnd = end;
            }

            public ParsedDateTime getStartTime() { return mStart; }
            public ParsedDateTime getEndTime()   { return mEnd; }

            public String toString() {
                StringBuilder sb = new StringBuilder();
                sb.append("[start=").append(mStart.toString());
                sb.append(", end=").append(mEnd.toString());
                sb.append("]");
                return sb.toString();
            }
        }
    }

    /**
     * @author tim
     *
     * The output of an RRULE or EXRULE rule -- corresponds to a RECUR value in an iCal specification
     *
     */
    public static class SimpleRepeatingRule implements IInstanceGeneratingRule {
        public SimpleRepeatingRule(ParsedDateTime dtstart, ParsedDuration duration, 
                ZRecur recur, InviteInfo invId)
        {
            mDtStart = dtstart;
            mRecur = recur;
            mInvId = invId;
            mDuration = duration;
        }
        
        public int getType() { return TYPE_REPEATING; }
        public Iterator addRulesIterator() { return null; }
        public Iterator subRulesIterator() { return null; }

        public void setInviteId(InviteInfo invId) {
            mInvId = invId;
        }
        
        public InviteInfo getInviteInfo() {
            return mInvId;
        }
        
        public Element toXml(Element parent) {
            Element rule = parent.addElement(MailService.E_CAL_RULE);

            // FREQ
            String freq = IcalXmlStrMap.sFreqMap.toXml(mRecur.getFrequency().toString());
            rule.addAttribute(MailService.A_CAL_RULE_FREQ, freq);

            // UNTIL or COUNT
            ParsedDateTime untilDate = mRecur.getUntil();
            if (untilDate != null) {
                Element untilElt = rule.addElement(MailService.E_CAL_RULE_UNTIL);
                untilElt.addAttribute(MailService.A_CAL_DATETIME,
                                      untilDate.getDateTimePartString(false));
            } else {
                int count = mRecur.getCount();
                if (count > 0) {
                    rule.addElement(MailService.E_CAL_RULE_COUNT).addAttribute(MailService.A_CAL_RULE_COUNT_NUM, count);
                }
            }

            // INTERVAL
            int ival = mRecur.getInterval();
            if (ival > 0) {
                rule.addElement(MailService.E_CAL_RULE_INTERVAL).
                    addAttribute(MailService.A_CAL_RULE_INTERVAL_IVAL, ival);
            }

            // BYSECOND
            List<Integer> bySecond = mRecur.getBySecondList();
            if (!bySecond.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYSECOND).
                    addAttribute(MailService.A_CAL_RULE_BYSECOND_SECLIST, ZRecur.listAsStr(bySecond));
            }

            // BYMINUTE
            List <Integer> byMinute = mRecur.getByMinuteList();
            if (!byMinute.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYMINUTE).
                addAttribute(MailService.A_CAL_RULE_BYMINUTE_MINLIST, ZRecur.listAsStr(byMinute));
            }

            // BYHOUR
            List<Integer> byHour = mRecur.getByHourList();
            if (!byHour.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYHOUR).
                    addAttribute(MailService.A_CAL_RULE_BYHOUR_HRLIST, ZRecur.listAsStr(byHour));
            }

            // BYDAY
            List<ZRecur.ZWeekDayNum> byDay = mRecur.getByDayList();
            if (!byDay.isEmpty()) {
                Element bydayElt = rule.addElement(MailService.E_CAL_RULE_BYDAY);
                for (ZRecur.ZWeekDayNum wdn : byDay) {
                    Element wkdayElt = bydayElt.addElement(MailService.E_CAL_RULE_BYDAY_WKDAY);
                    if (wdn.mOrdinal != 0) 
                        wkdayElt.addAttribute(MailService.A_CAL_RULE_BYDAY_WKDAY_ORDWK, wdn.mOrdinal);
                    wkdayElt.addAttribute(MailService.A_CAL_RULE_DAY, wdn.mDay.toString());
                }
            }

            // BYMONTHDAY
            List<Integer> byMonthDay = mRecur.getByMonthDayList();
            if (!byMonthDay.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYMONTHDAY).
                   addAttribute(MailService.A_CAL_RULE_BYMONTHDAY_MODAYLIST, ZRecur.listAsStr(byMonthDay));
            }

            // BYYEARDAY
            List<Integer> byYearDay = mRecur.getByYearDayList();
            if (!byYearDay.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYYEARDAY).
                    addAttribute(MailService.A_CAL_RULE_BYYEARDAY_YRDAYLIST, ZRecur.listAsStr(byYearDay));
            }

            // BYWEEKNO
            List<Integer> byWeekNo = mRecur.getByWeekNoList();
            if (!byWeekNo.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYWEEKNO).
                    addAttribute(MailService.A_CAL_RULE_BYWEEKNO_WKLIST, ZRecur.listAsStr(byWeekNo));
            }

            // BYMONTH
            List<Integer> byMonth = mRecur.getByMonthList();
            if (!byMonth.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYMONTH).
                    addAttribute(MailService.A_CAL_RULE_BYMONTH_MOLIST, ZRecur.listAsStr(byMonth));
            }

            // BYSETPOS
            List<Integer> bySetPos = mRecur.getBySetPosList();
            if (!bySetPos.isEmpty()) {
                rule.addElement(MailService.E_CAL_RULE_BYSETPOS).
                   addAttribute(MailService.A_CAL_RULE_BYSETPOS_POSLIST, ZRecur.listAsStr(bySetPos));
            }

            // WKST
            ZRecur.ZWeekDay wkst = mRecur.getWkSt();
            if (wkst != null) {
                rule.addElement(MailService.E_CAL_RULE_WKST).
                    addAttribute(MailService.A_CAL_RULE_DAY, wkst.toString());
            }

//            // x-name
//            Map xNames = mRecur.getExperimentalValues();
//            for (Iterator iter = mRecur.getExperimentalValues().entrySet().iterator();
//                 iter.hasNext(); ) {
//                Map.Entry entry = (Map.Entry) iter.next();
//                Element xElt = rule.addElement(MailService.E_CAL_RULE_XNAME);
//                xElt.addAttribute(MailService.A_CAL_RULE_XNAME_NAME, (String) entry.getKey());
//                xElt.addAttribute(MailService.A_CAL_RULE_XNAME_VALUE, (String) entry.getValue());
//            }

            return rule;
        }
        
        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) 
        {
            if (mDtStart == null) {
                ZimbraLog.calendar.warn("Unable to expand a recurrence with no DTSTART");
                return new ArrayList<Instance>();
            }

            List<Instance> toRet = null;
            try {
                long duration = 0;
                if (mDuration != null)
                    duration = mDuration.getDurationAsMsecs(mDtStart.getDate());
                List <java.util.Date> dateList = mRecur.expandRecurrenceOverRange(mDtStart, start - duration, end);

                toRet = new ArrayList<Instance>(dateList.size());
                
                int num = 0;
                for (Iterator iter = dateList.iterator(); iter.hasNext();) {
                    Date cur = (Date)iter.next();
                    long instStart = cur.getTime();
                    long instEnd;
                    if (mDuration != null)
                        instEnd = mDuration.addToDate(cur).getTime();
                    else
                        instEnd = instStart;
                    if (instStart < end && instEnd > start) {
                        toRet.add(num++, new Instance(calItem, mInvId, false, instStart, instEnd, false));
                    }
                }
            } catch (ServiceException se) {
                // Bugs 3172 and 3240.  Ignore recurrence rules with bad data.
                ZimbraLog.calendar.warn("ServiceException expanding recurrence rule: " + mRecur.toString(), se);
                toRet = new ArrayList<Instance>();
            } catch (IllegalArgumentException iae) {
                // Bugs 3172 and 3240.  Ignore recurrence rules with bad data.
            	ZimbraLog.calendar.warn("Invalid recurrence rule: " + mRecur.toString(), iae);
                toRet = new ArrayList<Instance>();
            }
            return toRet;
        }
        
        public ZRecur getRule() { return mRecur; }


        public ParsedDateTime getStartTime() {
            return mDtStart;
        }
        public ParsedDateTime getEndTime() {
            // FIXME: 
            
//            if (mCount > 0) {
//
//                resetIterator();
//                long latestTime = peekNextInstance().getEnd();
//                for (int i = 0; i < mCount && hasNextInstance(); i++) {
//                    getNextInstance();
//                }
//                return peekNextInstance().getEnd();
//            }
            if (mRecur != null) {
                ParsedDateTime until = mRecur.getUntil();
                if (until != null && mDtStart != null) {
                    assert(mDuration != null);
                    ParsedDateTime endPdt = mDtStart.add(mDuration);
                    ParsedDateTime end = endPdt.cloneWithNewDate(until);
                    return end;
                }
            }
            return ParsedDateTime.MAX_DATETIME;
        }
        
//      /**
//      * @param rule
//      */
//     private void computeEndTime(RRule rule) {
//         // TODO Auto-generated method stub
//         Recur recur = rule.getRecur();
//         Date until = recur.getUntil();
//         if (until != null) {
//             mEnd = until.getTime();
//             return;
//         }
//         String freq = recur.getFrequency();
//         int interval = recur.getInterval();
//         if (interval == -1) {
//             interval = 1;
//         }
//         int count = recur.getCount();
//         if (Recur.DAILY.equals(freq)) {
//             java.util.Calendar cal = java.util.Calendar.getInstance();
//             cal.setTimeInMillis(mStart);
//             cal.add(java.util.Calendar.DAY_OF_YEAR, interval * (count - 1));
//             mEnd = cal.getTimeInMillis();
//             return;
//         }
//         // FIXME!
//         mEnd = mStart+1;
//     }
     
     
        
        
        public String toString() {
            StringBuilder toRet = new StringBuilder();
            toRet.append("RULE(FIRST=").append(mDtStart != null ? mDtStart.getDate() : "<none>");
            toRet.append(",DUR=").append(mDuration);
            toRet.append(",RECUR=").append(mRecur.toString());
            return toRet.toString(); 
        }
        
        private static final String FN_DTSTART = "dts";
        private static final String FN_DURATION = "dur";
        private static final String FN_RECUR = "recur";
        private static final String FN_INVID = "inv";

        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_RULE_TYPE, RULE_SIMPLE_REPEATING_RULE);
            meta.put(FN_DTSTART, mDtStart);
            meta.put(FN_DURATION, mDuration);
            meta.put(FN_RECUR, mRecur);
            meta.put(FN_INVID, mInvId.encodeMetadata());
            
            return meta;
        }
        
        public Object clone()
        {
            return new SimpleRepeatingRule(mDtStart, mDuration, mRecur, mInvId);
        }
        
        public SimpleRepeatingRule(Metadata meta, TimeZoneMap tzmap) throws ServiceException {
//          mDtStart = meta.getAttributeLong(FN_DTSTART);
//          mDuration = meta.getAttributeLong(FN_DURATION);
            try {
                mDtStart = ParsedDateTime.parse(meta.get(FN_DTSTART, null), tzmap);
                mDuration = ParsedDuration.parse(meta.get(FN_DURATION, null));
            } catch (ParseException e) {
                throw ServiceException.FAILURE("ParseException ", e);
            }
            mRecur = new ZRecur(meta.get(FN_RECUR).toString(), tzmap);
            
            mInvId = InviteInfo.fromMetadata(meta.getMap(FN_INVID), tzmap);
        }

        // define the value
        private ParsedDateTime mDtStart;
        private ZRecur mRecur;
        private ParsedDuration mDuration;
        private InviteInfo mInvId;
    }    
    
    /**
     * @author tim
     * 
     * Base class: models a set of rules as
     *    DTSTART + (RRULEs + RDATEs - EXRULEs - EXDATEs)
     *    
     *    
     *  Not instantiated directly -- used to build either a Rule (which can have Exceptions) or 
     *  an ExceptionRule (ie component with a RECURRENCE-ID property)
     *
     */
    public static abstract class CompoundRuleBase implements IRecurrence {
        protected CompoundRuleBase(ParsedDateTime dtstart, ParsedDuration duration, InviteInfo invId, 
                List<IRecurrence> addRules, 
                List<IRecurrence> subtractRules)
        {
            mDtStart = dtstart;
            mDuration = duration;
            mInvId = invId;
            mAddRules = new MultiRuleSorter(addRules);
            if (subtractRules.size() > 0) {
                mSubtractRules = new MultiRuleSorter(subtractRules);
            } else {
                mSubtractRules = null;
            }
        }
        
        public void setInviteId(InviteInfo invId) {
            mInvId = invId;
            
            mAddRules.setInviteId(invId);
            if (mSubtractRules != null) {
                mSubtractRules.setInviteId(invId);
            }
        }
        
        public InviteInfo getInviteInfo() {
            return mInvId;
        }
        
        protected CompoundRuleBase(ParsedDateTime dtstart, ParsedDuration duration, 
                InviteInfo invId)
        {
            mDtStart = dtstart;
            mDuration = duration;
            mInvId = invId;
            mAddRules = null;
            mSubtractRules = null;
        }
        
        public Iterator<IRecurrence> addRulesIterator() { return mAddRules.iterator(); }
        public Iterator<IRecurrence> subRulesIterator() { 
            if (mSubtractRules != null) {
                return mSubtractRules.iterator();
            }
            return null;
        }
        
        
        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) 
        {
            if (mDtStart == null) {
                ZimbraLog.calendar.warn("Unable to expand a recurrence with no DTSTART");
                return new ArrayList<Instance>(0);
            }

            // expansion = DTSTART + RRULEs + RDATEs - (EXRULEs + EXDATEs)

            // RRULEs + RDATEs
            List<Instance> toAdd;
            if (mAddRules != null)
                toAdd = mAddRules.expandInstances(calItem, start, end);
            else
                toAdd = new ArrayList<Instance>(1);

            // DTSTART
            long firstStart = mDtStart.getUtcTime();
            long firstEnd = mDuration != null ? mDtStart.add(mDuration).getUtcTime() : firstStart;
            if (firstStart < end && firstEnd > start) {
                CalendarItem.Instance first = null;
                if (toAdd.size() > 0) {
                    first = (CalendarItem.Instance)toAdd.get(0);
                }

                CalendarItem.Instance dtstartInst = new CalendarItem.Instance(
                        calItem, mInvId, false, firstStart, firstEnd, false);
                if (first == null || first.compareTo(dtstartInst) != 0) {
                    assert(first == null || first.compareTo(dtstartInst) > 0); // first MUST be after dtstart!
                    toAdd.add(0,dtstartInst);
                }
            }

            // -(EXRULEs + EXDATEs)
            if (mSubtractRules == null)
                return toAdd;
            List<Instance> toExclude = mSubtractRules.expandInstances(calItem, start, end);
            return ListUtil.subtractSortedLists(
                    toAdd, toExclude, new Instance.StartTimeComparator());
        }
        
        public Element toXml(Element parent) {
            if (mAddRules != null) {
                Element addElt = parent.addElement(MailService.E_CAL_ADD);
                mAddRules.toXml(addElt);
            }
            if (mSubtractRules != null) {
                Element excludeElt = parent.addElement(MailService.E_CAL_EXCLUDE);
                mSubtractRules.toXml(excludeElt);
            }
            return parent;
        }
        
        
        public ParsedDateTime getStartTime() {
            return mDtStart;
        }
        
        public ParsedDateTime getEndTime() {
            if (mAddRules != null) {
                return mAddRules.getEndTime(); // FIXME should take into account EXCEPTIONS?
            } else if (mDtStart != null) {
                return mDtStart.add(mDuration);
            } else {
                return null;
            }
        }
        
        static final String FN_DTSTART = "dts";
        static final String FN_DURATION = "duration";
        static final String FN_ADDRULES = "add";
        static final String FN_SUBRULES = "sub";
        static final String FN_INVID = "invid";
        
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_DTSTART, mDtStart);
            meta.put(FN_DURATION, mDuration);
            if (mAddRules != null)
                meta.put(FN_ADDRULES, mAddRules.encodeMetadata());
            if (mSubtractRules != null)
                meta.put(FN_SUBRULES, mSubtractRules.encodeMetadata());
            meta.put(FN_INVID, mInvId.encodeMetadata());

            return meta;
        }
        
        protected CompoundRuleBase(Metadata meta, TimeZoneMap tzmap) 
        throws ServiceException, ParseException {
            String str = meta.get(FN_DTSTART, null);
            mDtStart = ParsedDateTime.parse(str, tzmap);
            mDuration = ParsedDuration.parse(meta.get(FN_DURATION, null));

            Metadata metaRules = meta.getMap(FN_ADDRULES, true);
            if (metaRules != null) {
                mAddRules = new MultiRuleSorter(metaRules, tzmap);
            }
            Metadata metaSubrules = meta.getMap(FN_SUBRULES, true);
            if (metaSubrules != null) {
                mSubtractRules = new MultiRuleSorter(metaSubrules, tzmap);
            }

            mInvId = InviteInfo.fromMetadata(meta.getMap(FN_INVID), tzmap);
        }
        
        protected CompoundRuleBase(ParsedDateTime dtstart, ParsedDuration duration, 
                MultiRuleSorter addRules, MultiRuleSorter subtractRules, 
                InviteInfo invID) 
        {
            mDtStart = dtstart;
            mDuration = duration;
            mAddRules = addRules;
            mSubtractRules = subtractRules;
            mInvId = invID;
        }
        
        public String toString() {
            StringBuffer toRet = new StringBuffer();
            toRet.append("FIRST=").append(mDtStart != null ? mDtStart.getDate() : "<none>");
            toRet.append(",DUR=").append(mDuration);
            if (mAddRules != null) {
                toRet.append("\n\t\tADD[").append(mAddRules.toString()).append("]");
            }
            if (mSubtractRules != null) {
                toRet.append("\n\t\tSUBTRACT[").append(mSubtractRules.toString()).append("]");
            }
            return toRet.toString(); 
        }

        public abstract Object clone();
        
        protected ParsedDateTime mDtStart;
        protected ParsedDuration mDuration;
        
        protected MultiRuleSorter mAddRules; // RRULE, RDATE
        protected MultiRuleSorter mSubtractRules; // RRULE, RDATE
        protected InviteInfo mInvId;
    }
    
//
// This is commented-out for compatability (not supported by many CUAs) --but leave the code here hopefully 
// we can figure out a way to enable it eventually...
//    
//
//    /**
//     * @author tim
//     * 
//     * Represents the range of instances specified by a RECURRENCE_ID iCalendar component
//     */
//    public static class RecurrenceRange
//    {
//        public static final int NOT_RANGE = 1;
//        public static final int THIS_AND_FUTURE = 2;
//        public static final int THIS_AND_PRIOR = 3;
//        
//        static final String FN_RANGE_TYPE = "rgtyp";
//        static final String FN_RECURRENCE_ID = "recurId";
//        
//        private ParsedDateTime mRecurrenceId;
//        private int mRangeType = NOT_RANGE;
//        
//        RecurrenceRange(ParsedDateTime recurrenceId, int rangeType) {
//            mRecurrenceId = recurrenceId;
//            assert(rangeType == NOT_RANGE || rangeType == THIS_AND_FUTURE || rangeType == THIS_AND_PRIOR);
//            mRangeType = rangeType;
//        }
//        
//        public Metadata encodeMetadata()
//        {
//            Metadata meta = new Metadata();
//            
//            meta.put(FN_RECURRENCE_ID, mRecurrenceId);
//            meta.put(FN_RANGE_TYPE, Integer.toString(mRangeType));
//            
//            return meta;
//        }
//        
//        protected RecurrenceRange(Metadata meta, TimeZoneMap tzMap) throws ServiceException, ParseException
//        {
//            mRecurrenceId = ParsedDateTime.parse(meta.get(FN_RECURRENCE_ID), tzMap);
//            mRangeType = (int)meta.getLong(FN_RANGE_TYPE);
//        }
//        
//        public boolean matches(long date) {
//            // TODO we don't currently handle ranges!
//            return (mRecurrenceId.compareTo(date) == 0);
//        }
//        
//        
//        public String toString() {
//            StringBuffer toRet = new StringBuffer();
//            switch (mRangeType) {
//            case NOT_RANGE:
//                toRet.append("(RECURRENCE-ID=").append(mRecurrenceId.toString()).append(")");
//                break;
//            case THIS_AND_FUTURE:
//                toRet.append("(RECURRENCE-ID=RANGE:THISANDFUTURE;").append(mRecurrenceId.toString()).append(")");
//                break;
//            case THIS_AND_PRIOR:
//                toRet.append("(RECURRENCE-ID=RANGE:THISANDPRIOR;").append(mRecurrenceId.toString()).append(")");
//                break;
//            }
//            return toRet.toString(); 
//        }
//    }
    
    /**
     * @author tim
     * 
     * an RFC2446 CANCEL request to cancel an instance or range of instances
     * 
     * basically, this intercepts one or more Recurrence instances, and replaces them with nothing
     */
    public static class CancellationRule implements IException
    {
        static private final String FN_RECURRENCE_ID = "recurId";
        
        private RecurId mRecurRange;
        
        public CancellationRule(RecurId recurId) {
            mRecurRange = recurId;
        }
        
        public int getType() { return TYPE_CANCELLATION; }
        public Iterator addRulesIterator() { return null; }
        public Iterator subRulesIterator() { return null; }
        
        public void setInviteId(InviteInfo invId) {}
        public InviteInfo getInviteInfo() { return null; } 
        
        CancellationRule(Metadata meta, TimeZoneMap tzmap) 
        throws ServiceException, ParseException
        {
            mRecurRange = RecurId.decodeMetadata(meta.getMap(FN_RECURRENCE_ID), tzmap);
        }
        
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            
            meta.put(FN_RECURRENCE_ID, mRecurRange.encodeMetadata());
            return meta;
        }
        
        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) {
            return new ArrayList<Instance>(); // NONE!
        }
        
        public ParsedDateTime getStartTime() {
            return null;
        }
        
        public ParsedDateTime getEndTime() {
            return null;
        }

        public Object clone() {
            return new CancellationRule(mRecurRange);
        }
        
        public Element toXml(Element parent) {
            Element elt = parent.addElement(MailService.E_CAL_CANCEL);
            mRecurRange.toXml(elt);
            
            return elt;
        }
        
        public boolean matches(long date) {
            return mRecurRange.withinRange(date);
        }
        
        public RecurId getRecurId() {
            return mRecurRange;
        }
    }
    
    
    /**
     * @author tim
     *
     * A recurrence-rule that has a RECURRENCE-ID and can tell you if it applies
     * or not
     */
    public static class ExceptionRule extends CompoundRuleBase implements IException
    {
        public ExceptionRule(RecurId recurrenceId, 
                ParsedDateTime dtstart, ParsedDuration duration, 
                InviteInfo invId, 
                List<IRecurrence> addRules, List<IRecurrence> subtractRules)
        {
            super(dtstart, duration, invId, addRules, subtractRules);
            mRecurRange = recurrenceId;
        }

        public ExceptionRule(RecurId recurrenceId,
                ParsedDateTime dtstart, ParsedDuration duration, 
                InviteInfo invId)  
        {
            super(dtstart, duration, invId);
            mRecurRange = recurrenceId;
        }
        
        protected ExceptionRule(Metadata meta, TimeZoneMap tzmap) throws ParseException, ServiceException
        {
            super(meta, tzmap);
            mRecurRange = RecurId.decodeMetadata(meta.getMap(FN_RECURRENCE_ID), tzmap);
        }
        
        public int getType() { return TYPE_EXCEPTION; }

        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) 
        {
            List<Instance> toRet = super.expandInstances(calItem, start, end);
            
            for (Iterator iter = toRet.iterator(); iter.hasNext();) {
                CalendarItem.Instance cur = (CalendarItem.Instance)iter.next();
                cur.setIsException(true);
            }
            return toRet;
        }
        

        public Element toXml(Element parent) {
            Element elt = parent.addElement(MailService.E_CAL_EXCEPT);
            mRecurRange.toXml(elt);
            
            // now put the 
            super.toXml(elt);
            
            return elt;
        }
        
        static final String FN_RECURRENCE_ID = "recurId";
        static final String FN_RANGE_TYPE = "rgtyp";
        public Metadata encodeMetadata()
        {
            Metadata meta = super.encodeMetadata();
            meta.put(FN_RULE_TYPE, RULE_EXCEPTION_RULE);
            meta.put(FN_RECURRENCE_ID, mRecurRange.encodeMetadata());
            return meta;
        }

        public boolean matches(long date) {
            return mRecurRange.withinRange(date);
        }

        public RecurId getRecurId() {
            return mRecurRange;
        }
        
        public String toString() {
            StringBuffer toRet = new StringBuffer("EXCEPTION(");
            toRet.append(mRecurRange.toString());
            toRet.append(" ");
            toRet.append(super.toString());
            return toRet.toString();
        }
        
        private ExceptionRule(ExceptionRule other) {
            super(other.mDtStart, other.mDuration, 
                    other.mAddRules == null ? null : (MultiRuleSorter)other.mAddRules.clone(), 
                            other.mSubtractRules == null ? null : (MultiRuleSorter)other.mSubtractRules.clone(), 
                                    other.mInvId);
            mRecurRange = other.mRecurRange;
        }
        
        public Object clone() {
            return new ExceptionRule(this);
        }
        
        private RecurId mRecurRange; 
    }
    
    /**
     * @author tim
     *
     * Models the initial "master" rule in a ruleset -- ie the one and only component for a 
     * particular UID that has no RECURRENCE-ID setting
     * 
     * To get the output of this rule you basically:
     *     For each Instance:   ( DTSTART + (RRULEs+RDATES-EXRULEs-EXDATEs) )
     *        Check the RECURRENCE-ID of each Exception 
     *           if it matches, then use that Exceptions Instances
     *           else return the Instance
     *        
     */
    public static class RecurrenceRule extends CompoundRuleBase 
    {
        public RecurrenceRule(ParsedDateTime dtstart, ParsedDuration duration, 
                InviteInfo invId, 
                List<IRecurrence> addRules, List<IRecurrence> subtractRules)
        {
            super(dtstart, duration, invId, addRules, subtractRules);
            mExceptions = new ArrayList<IException>();
        }
        
        public RecurrenceRule(ParsedDateTime dtstart, ParsedDuration duration,
                InviteInfo invId)
        {
            super(dtstart, duration, invId);
            mExceptions = new ArrayList<IException>();
        }
        
        public int getType() { return TYPE_RECURRENCE; }
        
        public void setInviteId(InviteInfo invId) {
            super.setInviteId(invId);
            assert(mExceptions.size() == 0); // must not call this on an calendar item-owned Invite
        }
        
        public Iterator<IException> exceptionsIter() {
            return mExceptions.iterator();
        }

        public RecurrenceRule(Metadata meta, TimeZoneMap tzmap) 
        throws ServiceException, ParseException {
            super(meta, tzmap);
            
            int numEx = (int) meta.getLong(FN_NUM_EXCEPTIONS);
            mExceptions = new ArrayList<IException>(numEx);

            for (int i = 0; i < numEx; i++) {
                if (meta.containsKey(FN_EXCEPTION+i)) {
                    mExceptions.add(i, new ExceptionRule(meta.getMap(FN_EXCEPTION+i), tzmap));
                } else if (meta.containsKey(FN_CANCELLATION+i)) {
                    mExceptions.add(i, new CancellationRule(meta.getMap(FN_CANCELLATION+i), tzmap));
                }
            }
        }

        public Element toXml(Element parent) {
            for (Iterator iter = mExceptions.iterator(); iter.hasNext();) {
                IException cur = (IException)iter.next();
                cur.toXml(parent);
            }
            super.toXml(parent);
            
            return parent;
        }
        
        
        public void addException(IException rule) {
            mExceptions.add(rule);
        }
        
        public List<Instance> expandInstances(CalendarItem calItem, long start, long end) {
            // get the list of instances that THIS rule expands into
            List<Instance> stdInstances = super.expandInstances(calItem, start, end);

            List exceptInstances[] = new List[mExceptions.size()]; // as big as we might need
            int numActiveExceptions = 0;
            
            // now, iterate through the instances in THIS rule and for each one,
            // check all the EXCEPTION rules to see if they have a RECURRENCE_ID that
            // matches.  If they do, then this instance is REMOVED from *our* set,
            // and the EXCEPTION's output is added into the set of lists to add. 
            for (Iterator stdIter = stdInstances.iterator(); stdIter.hasNext();) {
                CalendarItem.Instance cur = (CalendarItem.Instance)stdIter.next();
                CalendarItem.Instance origCur = cur;
            
                int exceptNum = 0;
                for (Iterator exceptIter = mExceptions.iterator(); exceptIter.hasNext();exceptNum++) {
                    IException except = (IException)exceptIter.next();
                    
                    if (except != null) {
                
                        if (cur == null && except.matches(origCur.getStart())) {
                            // hmm - there must be two different exceptions that both match this
                            // original instance!  What do we do here?  TODO read more to see
                            // what the RFC says -- for now we'll log and add the extra instances...
                            if (exceptInstances[exceptNum] == null) {
                                numActiveExceptions++;                            
                                exceptInstances[exceptNum] = except.expandInstances(calItem, start, end);
                            }
                        }
                        if (cur != null && except.matches(cur.getStart())) {
                            stdIter.remove(); // matched!  remove the current instance from our list
                            
                            cur = null;
                            if (exceptInstances[exceptNum] == null) {
                                numActiveExceptions++;                            
                                exceptInstances[exceptNum] = except.expandInstances(calItem, start, end);
                            }
                        }
                    }
                }
            }

            List<Instance> toRet;
            if (numActiveExceptions == 0){
                toRet = stdInstances;
            } else {
                toRet = new ArrayList<Instance>();
                List toAdd[] = new List[numActiveExceptions + 1];
                toAdd[0] = stdInstances;
                int off = 1;
                for (int i = 0; i < exceptInstances.length; i++) {
                    if (exceptInstances[i] != null) {
                        toAdd[off++] = exceptInstances[i];
                    }
                }
                
                // WTF does this mean?
                 assert(off == numActiveExceptions+1);
                
                ListUtil.mergeSortedLists(toRet, toAdd, true);
            }

            return toRet;
        }
        
        public String toString() {
            StringBuffer toRet = new StringBuffer();
            
            toRet.append("RECUR(").append(super.toString());
            for (Iterator iter = mExceptions.iterator(); iter.hasNext();) {
                IException ex = (IException)iter.next();
                toRet.append("\n\t\t").append(ex.toString());
            }
            toRet.append(")");
            
            return toRet.toString();
        }
        
        
        static final String FN_NUM_EXCEPTIONS = "numEx";
        static final String FN_EXCEPTION = "ex";
        static final String FN_CANCELLATION = "ca";
        
        public Metadata encodeMetadata()
        {
            Metadata meta = super.encodeMetadata();
            
            meta.put(FN_RULE_TYPE, Integer.toString(RULE_RECURRENCE_RULE));
            meta.put(FN_NUM_EXCEPTIONS, Integer.toString(mExceptions.size()));
            for (int i = 0; i < mExceptions.size(); i++) {
                IException cur = (IException)mExceptions.get(i);
                if (cur instanceof ExceptionRule) {
                    meta.put(FN_EXCEPTION+i, cur.encodeMetadata());
                } else {
                    meta.put(FN_CANCELLATION+i, cur.encodeMetadata());
                }
            }
            return meta;
        }
        
        private RecurrenceRule(RecurrenceRule other) {
            super(other.mDtStart, other.mDuration, 
                    other.mAddRules == null ? null : (MultiRuleSorter)other.mAddRules.clone(), 
                            other.mSubtractRules == null ? null : (MultiRuleSorter)other.mSubtractRules.clone(), 
                                    other.mInvId);
            mExceptions = new ArrayList<IException>();
            for (Iterator iter = other.mExceptions.iterator(); iter.hasNext();) {
                IException cur = (IException)iter.next();
                mExceptions.add((IException) cur.clone());
            }
        }
        
        public Object clone() {
            return new RecurrenceRule(this);
        }
        
        
        protected List<IException> mExceptions;
    }
    
}
