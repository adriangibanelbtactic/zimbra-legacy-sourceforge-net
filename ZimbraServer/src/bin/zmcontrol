#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1
# 
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite Server.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
my $id = `id -u -n`;
chomp $id;
if ($id ne "zimbra") {die "Run as the zimbra user!\n";}

our $zimbra_home = "/opt/zimbra";

use lib "/opt/zimbra/zimbramon/lib";
use Zimbra::Util::Common;
use Zimbra::Mon::Logger;

use Getopt::Std;
use File::Temp qw/ tempfile /;
my (undef, $zmcontrolLogfile) = tempfile("zmcontrol.out.XXXXX", DIR=>"/tmp",  OPEN=>0);

my $timeout = 180;
$SIG{ALRM} = sub { print "Timeout after $timeout seconds\n"; exit(1) };
my $now = time();
my $cache_file = "${zimbra_home}/log/.zmcontrol.cache";
my $localHostName = getHostName();
my $ldapMasterHere = isLdapMaster();
my $services;
my %startorder = ( 
	"ldap" 		=> 0,
	"logger" 	=> 1,
	"mailbox" 	=> 2,
	"imapproxy" => 3,
	"antispam" 	=> 4,
	"antivirus" => 5,
	"snmp" 		=> 6,
	"spell" 	=> 7,
	"mta" 		=> 8,
	"stats"		=> 9,
);

my %allservices = ( 
	"antivirus" => "/opt/zimbra/bin/zmantivirusctl", 
	"antispam" => "/opt/zimbra/bin/zmantispamctl", 
	"mta" => "/opt/zimbra/bin/zmmtactl", 
	"mailbox" => "/opt/zimbra/bin/zmmailboxctl", 
	"logger" => "/opt/zimbra/bin/zmloggerctl", 
	"snmp" => "/opt/zimbra/bin/zmswatchctl", 
	"ldap" => "/opt/zimbra/bin/ldap",
	"spell" => "/opt/zimbra/bin/zmspellctl",
	"imapproxy" => "/opt/zimbra/bin/zmperditionctl",
	"stats" => "/opt/zimbra/bin/zmstatctl",
);

my %rewrites = ( 
	"antivirus" => "antivirus", 
	"antispam" => "antispam", 
	"mta" => "antispam antivirus mta sasl", 
	"mailbox" => "webxml mailbox", 
	"perdition" => "perdition",
);

my %GlobalOpts = ();

my %DESC = (
	"start" => "Start services",
	"startup" => "Start services",
	"stop" => "Stop services",
	"shutdown" => "Stop services",
	"maintenance" => "Toggle maintenance mode",
	"status" => "Display service status",
);

my %COMMANDS = (
	"start" => \&doStartup,
	"startup" => \&doStartup,
	"stop" => \&doShutdown,
	"shutdown" => \&doShutdown,
	"maintenance" => \&setMaintenanceMode,
	"status" => \&doStatus,
);

my %REMOTECOMMANDS = (
	"start" => "startup",
	"startup" => "startup",
	"stop" => "shutdown",
	"shutdown" => "shutdown",
	"maintenance" => "maintenance",
	"status" => "status",
);


$| = 1;

unless ( getopts( 'vhH:', \%GlobalOpts ) ) { usage(); }

if ( ! $GlobalOpts{H} ) { $GlobalOpts{H} = $localHostName; chomp $GlobalOpts{H}; }

if ( $GlobalOpts{h} ) { usage(); }
if ( $GlobalOpts{v} ) { displayVersion(); exit 1;}

# Commands: start, stop, maintenance and status
my $command = $ARGV[0];

unless (defined ($COMMANDS{$command})) {usage();}

if ($GlobalOpts{H} ne $localHostName) {
	exit (runRemoteCommand ($command));
}

exit (&{$COMMANDS{$command}}($ARGV[1]));

#
# Functions
#
sub runRemoteCommand {
	my $cmd = shift;
	my $cstr = "HOST:$GlobalOpts{H} $REMOTECOMMANDS{$cmd}";

	open (REMOTE, "echo $cstr | /opt/zimbra/libexec/zmrc $GlobalOpts{H} |") or 
		die "Can't contact $GlobalOpts{H}";

	while (<REMOTE>) {
		if (/^STARTCMD: (\S+) .*/) {
			#print "Host $1 starting\n";
		} elsif (/^ENDCMD: (\S+) .*/) {
			print "Host $1 complete\n";
			exit; # Since the pipe doesn't always like to close...
		} else {
			print "$_";
		}
	}
	close REMOTE;
}

sub doStatus {
	$services = getEnabledServices();
  alarm($timeout);
  my (undef, $statusfile) = tempfile("zmcontrol.status.XXXXX", DIR=>"/tmp",  OPEN=>0);
  my (undef, $errfile) = tempfile("zmcontrol.error.XXXXX", DIR=>"/tmp",  OPEN=>0);
	if (scalar(keys %$services) == 0) {
		print "Cannot determine services - exiting\n";
		return 1;
	}
	my $status = 0;
	print "Host $localHostName\n";
	foreach (sort keys %{$services}) {
		my $rc = 0xffff & system ("$allservices{$_} status > $statusfile 2> $errfile");
		$rc = $rc >> 8;
		if ($rc) {
      # this is an any ugly hack for 11266
			$status = 1 unless (/logger|spell|snmp/);
        
		}
		my $stat = sprintf "\t%-20s %10s\n",$_,($rc)?"Stopped":"Running";
		print "$stat";
		if ($rc) {
			open (ST, "$statusfile") or next;
			foreach my $s (<ST>) {
				print "\t\t$s";
			}
			close ST;
		}
	}
	unlink($statusfile);
	unlink($errfile);
  alarm(0);
	return $status;
}

sub startLdap {
	print "\tStarting ldap...";
	my $rc = 0xffff & system("/opt/zimbra/bin/ldap start > $zmcontrolLogfile 2>&1");
	$rc = $rc >> 8;
	print "Done.\n";
	return $rc;
}

sub doRewrite {
	my $rew = "";
	foreach (@_) {
		$rew .= " $rewrites{$_}";
	}
	Zimbra::Mon::Logger::Log ("info", "Rewriting configs $rew");
	my $rc = 0xffff & system("/opt/zimbra/libexec/zmmtaconfig $rew > $zmcontrolLogfile 2>&1");
	$rc = $rc >> 8;
	return $rc;
}

sub doStartup {
	Zimbra::Mon::Logger::Log ("info", "Starting services");
	print "Host $localHostName\n";
	my $rc = 0;
	my $rrc = 0;
	if ($ldapMasterHere) {
		my $ldapStopped = 0xffff & system("/opt/zimbra/bin/ldap status > /dev/null 2>&1");
		if ($ldapStopped) {
			$rrc = startLdap();
		}
	}
	if ($rrc) {
		$rc = 1;
		my $out = `cat $zmcontrolLogfile`;
		print "FAILED\n";
		print "$out\n\n";
		exit (1);
	}
	unlink($zmcontrolLogfile);
	$services = getEnabledServices();
	if (scalar(keys %$services) == 0) {
		return 1;
	}
	if (defined ($$services{"ldap"}) ) {
		my $ldapStopped = 0xffff & system("/opt/zimbra/bin/ldap status > /dev/null 2>&1");
		if ($ldapStopped) {
			$rrc = startLdap();
			sleep 3;
		}
	}
	if ($rrc) {
		$rc = 1;
		my $out = `cat $zmcontrolLogfile`;
		print "FAILED\n";
		print "$out\n\n";
		exit (1);
	}

	doRewrite (sort keys %{$services});

	foreach (sort {$startorder{$a} <=> $startorder{$b}} keys %{$services}) {
		if ($_ eq "ldap") {next;}
		Zimbra::Mon::Logger::Log ("info", "Starting $_");
		print "\tStarting $_...";
		$rrc = 0xffff & system ("$allservices{$_} start norewrite > $zmcontrolLogfile 2>&1");
		$rrc = $rrc >> 8;
		if ($rrc) {
			$rc = 1;
			my $out = `cat $zmcontrolLogfile`;
			print "FAILED\n";
			print "$out\n\n";
		} else {
			print "Done.\n";
		}
		unlink($zmcontrolLogfile);
	}
	return $rc;
}

sub doShutdown {
	Zimbra::Mon::Logger::Log ("info", "Stopping services");
	print "Host $localHostName\n";
	my $rc = 0;
	my $rrc = 0;
  my $postfix_version = getLocalConfig("postfix_version");
	foreach (sort {$startorder{$b} <=> $startorder{$a}} keys %allservices) {
		Zimbra::Mon::Logger::Log ("info", "Stopping $_");
		if ($_ eq "ldap" && !(-d "/opt/zimbra/openldap/libexec") ) { next; }
		if ($_ eq "mta" && !(-d "/opt/zimbra/postfix-${postfix_version}/libexec") ) { next; }
		if ($_ eq "snmp" && !(-f "/opt/zimbra/bin/zmswatchctl") ) { next; }
		if ($_ eq "mailbox" && !(-d "/opt/zimbra/db/data") ) { next; }
		print "\tStopping $_...";
		$rrc = 0xffff & system ("$allservices{$_} stop > $zmcontrolLogfile 2>&1");
		$rrc = $rrc >> 8;
		if ($rrc) {
			$rc = 1;
			my $out = `cat $zmcontrolLogfile`;
			print "FAILED\n";
			print "$out\n\n";
		} else {
			print "Done\n";
		}
		unlink($zmcontrolLogfile);
	}
	return $rc;
}

sub setMaintenanceMode {
	my $mode = shift;
}

sub getLocalConfig {
	my $key = shift;
	if (defined ($ENV{zmsetvars})) {
		return $ENV{$key};
	}
	open CONF, "/opt/zimbra/bin/zmlocalconfig -x -s -q -m shell |" or
		die "Can't open zmlocalconfig: $!";
	my @conf = <CONF>;
	close CONF;

	chomp @conf;

	foreach (@conf) {
		my ($key, $val) = split '=', $_, 2;
		$val =~ s/;$//;
		$val =~ s/'$//;
		$val =~ s/^'//;
		$ENV{$key} = $val;
	}
	$ENV{zmsetvars} = 'true';
	return $ENV{$key};
}

sub getCachedServices {

  my %s = ();
	if (-f $cache_file && -M $cache_file <= 1) {
    open(CACHE, "<$cache_file");
    my @lines = <CACHE>;
    close CACHE;
    foreach (@lines) {
      chomp;
      $s{$_} = $_;
    }
  } else {
    print "Unable to determine enabled services. Cache is out of date or doesn't exist.\n"; 
    exit 1;
  }
  warn "Enabled services read from cache. Service list may be inaccurate.\n"
    if (scalar keys %s > 0 );
  return \%s;
}

sub getEnabledServices {
	unless (open (ZMPROV, "/opt/zimbra/bin/zmprov -l gs $localHostName 2>/dev/null |")) {
    warn "Unable to determine enabled services from ldap.\n";
    return getCachedServices();
  }
  my @lines = <ZMPROV>;
  unless (close ZMPROV) {
    warn "Unable to determine enabled services from ldap.\n";
    return getCachedServices();
  }

  my %s = ();
  foreach (@lines) {
    if (m/^zimbraServiceEnabled: (.*)/) {
      $s{$1} = $1;
    }
  }
  if (scalar keys %s > 0) {
    open (CACHE, ">$cache_file");
    foreach my $service (keys %s) {
      print CACHE "$service\n";
    }
    close(CACHE);
  }
  return \%s;
}

sub isLdapMaster {
	return (getLocalConfig("ldap_is_master") =~ /true/i);
}

sub getHostName {
	return (getLocalConfig("zimbra_server_hostname"));
}

sub displayVersion {
	my $platform = `/opt/zimbra/libexec/get_plat_tag.sh`;
	chomp $platform;
	my $string = "";
	if ($platform =~ /MACOSX/) {
		my $release=`grep -C1 CFBundleGetInfoString /Library/Receipts/zimbra-core.pkg/Contents/Info.plist | tail -1 | sed -e 's/\<[^>]*\>//g' -e 's/^ *//g' | awk -F, '{print $1}'`;
		$string = "Release $release $platform";
	} elsif ($platform =~ /DEBIAN/ || $platform =~ /UBUNTU/) {
		my $release = `dpkg -s zimbra-core | egrep '^Version:' | sed -e 's/Version: //'`;
		chomp $release;
		$string = "Release $release $platform";
	} elsif ($platform =~ /RPL/) {
		my $release = `conary q zimbra-core | cut -d= -f2`;
		$string = "Release $release $platform";

	} else {
		my $release = `rpm -q --queryformat "%{version}_%{release}" zimbra-core`;
		my $inst = localtime (`rpm -q --queryformat "%{installtime}" zimbra-core`);
		$string = "Release $release $platform";
	}

	my $rc = 0xffff & system ("/opt/zimbra/bin/zmprov -l gacf > /dev/null 2>&1");
	if (!$rc) {
		$rc = 0xffff & system 
			("/opt/zimbra/bin/zmprov -l gacf 2> /dev/null | grep -q 'zimbraComponentAvailable: hotbackup'");
		if ($rc) { $string .= " FOSS edition"; }
		else { $string .= " NETWORK edition"; }
	}
	print "\n\n$string\n\n";
}

sub usage {
	displayVersion();
	print "$0 [-v -h -H <host>] command [args]\n";
	print "\n";
	print "\t-v:	display version\n";
	print "\t-h:	print usage statement\n";
	print "\t-H:	Host name (localhost)\n";
	print "\n";
	print "\tCommand in:\n";
	foreach ( sort keys %COMMANDS ) {
		print "\t\t" . sprintf( "%-20s%30s", $_, $DESC{$_} ) ."\n";
	}

	print "\n";
	exit 1;
}
